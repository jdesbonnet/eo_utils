<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QuickMap ‚Äî Leaflet One‚ÄëPage App</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Geoman (drawing & editing) -->
  <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.14.1/dist/leaflet-geoman.css" />
  <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.14.1/dist/leaflet-geoman.min.js"></script>
  <!-- GeoTIFF support -->
  <script src="https://unpkg.com/geotiff@2.1.3/dist-browser/geotiff.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/geotiff@2.1.4-beta.0/dist-browser/geotiff.min.js"></script>

  <script src="https://unpkg.com/georaster@1.6.1/dist/georaster.browser.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/georaster@1.6.0/dist/georaster.browser.bundle.min.js"></script>

  <script src="https://unpkg.com/georaster-layer-for-leaflet@3.10.0/dist/georaster-layer-for-leaflet.min.js"></script>
  <!-- Import/Export helpers -->
  <script src="https://unpkg.com/tokml@0.4.0/tokml.js"></script>
  <script src="https://unpkg.com/@tmcw/togeojson@5.8.0/dist/togeojson.umd.js"></script>
  <!-- Screenshot (PNG export) -->
  <script src="https://unpkg.com/leaflet-simple-map-screenshoter@0.6.2/dist/leaflet-simple-map-screenshoter.min.js"></script>
  <script src="https://unpkg.com/leaflet-simple-map-screenshoter"></script>

  <!-- Icons (AwesomeMarkers) -->
<!--
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.4/leaflet.awesome-markers.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.4/leaflet.awesome-markers.js"></script>
-->

  <!-- Icons (AwesomeMarkers) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />



  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.4/leaflet.awesome-markers.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet.awesome-markers@2.0.5/dist/leaflet.awesome-markers.min.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.4/leaflet.awesome-markers.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet.awesome-markers@2.0.5/dist/leaflet.awesome-markers.min.js"></script>


  <style>
    :root{
      --bg:#0b1020; --panel:#121836; --muted:#8da2fb; --text:#e8ecff; --accent:#7cf; --soft:#1b2354;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #app{display:grid;grid-template-columns:320px 1fr;grid-template-rows:1fr;gap:0;height:100%}
    aside{background:linear-gradient(180deg,var(--panel),var(--soft));padding:16px;border-right:1px solid #2b356f;overflow:auto}
    aside h1{font-size:18px;margin:0 0 12px 0}
    aside .card{background:#0e1440;border:1px solid #283176;border-radius:16px;padding:12px;margin-bottom:12px;box-shadow:0 10px 25px rgba(0,0,0,.25)}
    aside label{display:block;font-size:12px;color:#a9b6ff;margin:8px 0 4px}
    aside input, aside select, aside textarea{width:100%;background:#0a1136;color:#e9ecff;border:1px solid #3140a0;border-radius:10px;padding:8px;outline:none}
    aside textarea{min-height:64px}
    aside .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    aside .btn{display:inline-flex;align-items:center;gap:8px;background:#1c2a86;border:1px solid #3040a5;color:#e8ecff;padding:8px 10px;border-radius:12px;cursor:pointer;margin:6px 4px 0 0}
    aside .btn:hover{background:#2032a6}
    #map{height:100%;width:100%}
    .muted{color:#99a7ff;font-size:12px}
    .small{font-size:12px}
    .section-title{font-weight:600;font-size:13px;color:#b8c3ff;margin-top:6px}
    .hr{height:1px;background:#2b356f;margin:10px 0;border-radius:2px}
    .pill{display:inline-block;font-size:11px;border:1px solid #2e3ca2;border-radius:999px;padding:4px 8px;background:#101954;color:#cfe0ff}
    .toolbar{display:flex;flex-wrap:wrap;gap:6px;margin-top:6px}
    .warn{color:#ffec9a}
  .btn.disabled{opacity:.5;filter:grayscale(0.3);cursor:not-allowed}
  .btn.disabled{opacity:.5;filter:grayscale(0.3);cursor:not-allowed}
    #map{position:relative}
    .presence{position:absolute;top:10px;right:10px;display:flex;gap:6px;z-index:5000}
    .presence .avatar{width:28px;height:28px;border-radius:999px;border:1px solid #2e3ca2;background:#0e1440;display:flex;align-items:center;justify-content:center;font-weight:700}
    .remote-cursor{display:inline-flex;align-items:center;gap:6px;background:rgba(14,20,64,.85);border:2px solid #3a49c3;border-radius:12px;padding:2px 6px;color:#fff;box-shadow:0 2px 8px rgba(0,0,0,.4);pointer-events:none}
    .remote-cursor .dot{width:8px;height:8px;border-radius:999px;background:#fff}
  </style>
</head>
<body>
<div id="app">
  <aside>
    <h1>üó∫Ô∏è QuickMap</h1>
    <div class="card">
      <div class="section-title">Drawing</div>
      <div class="muted small">Use the toolbar on the map (left) to add markers, lines, and polygons. Click a feature to select it.</div>
      <div class="hr"></div>
      <div class="section-title">Selected Feature</div>
      <div class="row">
        <div>
          <label>Stroke</label>
          <input type="color" id="strokeColor" value="#ff4757" />
        </div>
        <div>
          <label>Fill</label>
          <input type="color" id="fillColor" value="#2ed573" />
        </div>
      </div>
      <div class="row">
        <div>
          <label>Opacity</label>
          <input type="range" id="opacity" min="0" max="1" step="0.05" value="0.7" />
        </div>
        <div>
          <label>Line type</label>
          <select id="lineType">
            <option value="solid" selected>Solid</option>
            <option value="dash">Dashed</option>
            <option value="dot">Dotted</option>
          </select>
        </div>
      </div>
      <label>Marker icon</label>
      <select id="markerIcon">
        <option value="fa-location-dot,#d33">Red pin</option>
        <option value="fa-star,#f1c40f">Star (gold)</option>
        <option value="fa-flag,#3498db">Flag (blue)</option>
        <option value="fa-tree,#2ecc71">Tree (green)</option>
        <option value="fa-circle,#9b59b6">Circle (purple)</option>
      </select>
      <div class="hr"></div>
      <div class="section-title">Text</div>
      <label>Short label (shown on map)</label>
      <input id="labelText" placeholder="e.g., Gate 1" />
      <label>Popup text (longer notes, can use line breaks)</label>
      <textarea id="popupText" placeholder="Details shown on click"></textarea>
      <button class="btn" id="applyText"><i class="fa fa-tag"></i>Apply to Selected</button>
    </div>

    <div class="card">
      <div class="section-title">Freehand (Stylus) Lines</div>
      <div class="small muted">Draw a line directly with your Wacom or tablet pen.</div>
      <div class="row">
        <div>
          <label class="small">Pen-only</label>
          <select id="fhPenOnly"><option value="yes" selected>Yes</option><option value="no">No</option></select>
        </div>
        <div>
          <label class="small">Vertex spacing (m)</label>
          <input id="fhMinDist" type="number" min="0" step="1" value="5" />
        </div>
      </div>
      <div class="toolbar">
        <button class="btn" id="fhEnableBtn"><i class="fa fa-pen"></i>Enable Freehand</button>
        <button class="btn" id="fhDisableBtn"><i class="fa fa-stop"></i>Disable</button>
      </div>
      <p class="small muted" style="margin-top:8px">While enabled: press pen to screen and move to draw. Lift pen to finish.</p>
    </div>
    <div class="card">
      <div class="section-title">History</div>
      <div class="toolbar">
        <button class="btn" id="undoBtn" title="Ctrl/Cmd+Z"><i class="fa fa-rotate-left"></i>Undo</button>
        <button class="btn" id="redoBtn" title="Ctrl+Shift+Z or Ctrl+Y"><i class="fa fa-rotate-right"></i>Redo</button>
      </div>
      <p class="small muted">Keyboard: Ctrl/Cmd+Z (undo), Ctrl+Shift+Z or Ctrl+Y (redo).</p>
    </div>
    <div class="card">
      <div class="section-title">Collaboration (Experimental)</div>
      <label>Your name</label>
      <input id="collabName" placeholder="e.g., Casey" />
      <label>Room ID</label>
      <input id="collabRoom" placeholder="e.g., field-team-alpha" />
      <label>Server URL (WebSocket)</label>
      <input id="collabServer" placeholder="ws://localhost:8080/ws" />
      <div class="toolbar">
        <button class="btn" id="collabConnect"><i class="fa fa-plug"></i>Connect</button>
        <button class="btn" id="collabDisconnect"><i class="fa fa-power-off"></i>Disconnect</button>
      </div>
      <div class="row">
        <div>
          <label class="small">Broadcast my view</label>
          <select id="broadcastView">
            <option value="no" selected>No</option>
            <option value="yes">Yes</option>
          </select>
        </div>
        <div>
          <label class="small">Follow user</label>
          <select id="followUser"><option value="">(none)</option></select>
        </div>
      </div>
      <button class="btn" id="jumpToUser"><i class="fa fa-eye"></i>Jump to selected view</button>
      <p class="small muted">Multiple users can pan/zoom independently. Use the jump button to go to someone‚Äôs latest view. Names and cursors appear on the map. Feature authorship/time are stored in exports.</p>
    </div>

    <div class="card">
      <div class="section-title">Basemaps</div>
      <div class="toolbar">
        <button class="btn" id="osmBtn">OSM</button>
        <button class="btn" id="esriBtn">ESRI World Imagery</button>
      </div>
      <label class="small" style="margin-top:8px">Custom tile URL (e.g., https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png)</label>
      <input id="customTileUrl" placeholder="Enter template URL" />
      <button class="btn" id="addTileBtn"><i class="fa fa-layer-group"></i>Add Tile Layer</button>
    </div>

    <div class="card">
      <div class="section-title">GeoTIFF</div>
      <label>URL</label>
      <input id="tiffUrl" placeholder="https://example.com/rasters/elevation.tif" />
      <button class="btn" id="addTiffUrl"><i class="fa fa-image"></i>Add from URL</button>
      <div class="hr"></div>
      <label>Upload from file</label>
      <input type="file" id="tiffFile" accept=".tif,.tiff" />
    </div>

    <div class="card">
      <div class="section-title">Import</div>
      <div class="small muted">Import from GeoJSON or KML. Styles & labels are stored in properties and restored.</div>
      <input type="file" id="importFile" accept=".geojson,.json,.kml" />
    </div>

    <div class="card">
      <div class="section-title">Export</div>
      <div class="toolbar">
        <button class="btn" id="exportGeoJSON"><i class="fa fa-file-code"></i>GeoJSON</button>
        <button class="btn" id="exportKML"><i class="fa fa-file-export"></i>KML</button>
        <button class="btn" id="exportPNG"><i class="fa fa-file-image"></i>PNG</button>
      </div>
      <p class="small muted" style="margin-top:8px">Note: PNG export of third‚Äëparty tiles/rasters may require CORS; if blocked, try OSM or your own CORS‚Äëenabled tiles.</p>
    </div>

    <div class="muted small">Tip: Double‚Äëclick the map to finish drawing a line/polygon. Use the Geoman toolbar on the map to edit or delete features.</div>
  </aside>
  <div id="map"><div id="presence" class="presence"></div></div>
</div>

<script>
(function(){
  // Map init
  const map = L.map('map').setView([53.3498,-6.2603], 6);

  // Base layers
  const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    crossOrigin: true,
    attribution: '&copy; OpenStreetMap'
  }).addTo(map);

  const esri = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    maxZoom: 19,
    crossOrigin: true,
    attribution: 'Tiles &copy; Esri'
  });

  const baseLayers = { 'OSM': osm, 'ESRI World Imagery': esri };
  const overlays = {};
  L.control.layers(baseLayers, overlays, { collapsed: true }).addTo(map);

  // Screenshoter
  const screenshoter = L.simpleMapScreenshoter({ hidden: false, preventDownload:false, position:'topleft' });
  screenshoter.addTo(map);

  // Geoman controls
  map.pm.addControls({
    position: 'topleft',
    drawCircle: false,
    drawCircleMarker: false
  });

  // A group to hold user features
  const drawn = L.featureGroup().addTo(map);

  // Selected layer
  let selected = null;
  const selectLayer = (layer)=>{
    selected = layer;
    // sync UI from selected, where possible
    try{
      if(layer instanceof L.Marker){
        // nop
      } else if (layer instanceof L.Polyline){
        const oc = layer.options.color || '#ff4757';
        const fc = layer.options.fillColor || '#2ed573';
        document.getElementById('strokeColor').value = tinycolor(oc).toHexString();
        document.getElementById('fillColor').value = tinycolor(fc).toHexString();
        document.getElementById('opacity').value = layer.options.opacity ?? 0.7;
        const da = layer.options.dashArray;
        document.getElementById('lineType').value = da ? (da === '1, 6' ? 'dot' : 'dash') : 'solid';
      }
      const tt = layer?.getTooltip?.();
      document.getElementById('labelText').value = tt ? tt.getContent() : '';
      const pp = layer?.getPopup?.();
      document.getElementById('popupText').value = pp ? pp.getContent() : '';
    }catch(e){}
  };

  // Utility: tinycolor fallback (very small util)
  function tinycolor(c){
    const ctx = document.createElement('canvas').getContext('2d');
    ctx.fillStyle = c; // lets the browser parse
    const computed = ctx.fillStyle; // normalized like rgb(r,g,b)
    // convert to hex
    const m = computed.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
    if(!m) return { toHexString:()=> '#000000' };
    const [r,g,b] = [parseInt(m[1]),parseInt(m[2]),parseInt(m[3])];
    const hex = '#' + [r,g,b].map(v=> v.toString(16).padStart(2,'0')).join('');
    return { toHexString:()=>hex };
  }

  // Click to select logic for all created layers
  function attachCommon(layer){
    layer.addTo(drawn);
    layer.on('click', ()=> selectLayer(layer));
  }

  // Geoman create hooks to style & attach
  map.on('pm:create', e => {
    const layer = e.layer;
    attachCommon(layer);
    ensureLayerId(layer);

    if(layer instanceof L.Marker){
      // default awesome marker
      setMarkerIcon(layer, document.getElementById('markerIcon').value);
    } else if (layer instanceof L.Polyline){
      applyStyle(layer);
    }
    // default label/popup from inputs
    applyText(layer);
    selectLayer(layer);
  });

  // Style application helpers
  function applyStyle(layer){
    const stroke = document.getElementById('strokeColor').value;
    const fill = document.getElementById('fillColor').value;
    const op = parseFloat(document.getElementById('opacity').value);
    const lt = document.getElementById('lineType').value;
    const dash = lt==='dash' ? '6, 8' : (lt==='dot' ? '1, 6' : null);

    if(layer instanceof L.Polyline){
      const opts = { color: stroke, opacity: op, weight: 3, dashArray: dash };
      if(layer instanceof L.Polygon){
        opts.fillColor = fill; opts.fillOpacity = op; opts.fill = true;
      }
      layer.setStyle(opts);
    }
  }

  // Marker icons via AwesomeMarkers
  function setMarkerIcon(marker, value){
    const [iconName, color] = value.split(',');
    const icon = L.AwesomeMarkers.icon({ icon: iconName.replace('fa-',''), prefix:'fa', markerColor: getColorName(color), iconColor: 'white' });
    marker.setIcon(icon);
    marker.options._am = { iconName, color };// store for export
  }
  // Map a hex to closest awesome marker color name (simple)
  function getColorName(hex){
    const palette = {
      '#d33':'red', '#f1c40f':'orange', '#3498db':'blue', '#2ecc71':'green', '#9b59b6':'purple'
    };
    return palette[hex?.toLowerCase()] || 'cadetblue';
  }

  // Text bindings
  function applyText(layer){
    const label = document.getElementById('labelText').value.trim();
    const popup = document.getElementById('popupText').value.trim();

    if(label){
      const tooltipOpts = { permanent: true, direction:'center', className:'feature-label' };
      layer.bindTooltip(label, tooltipOpts).openTooltip();
    } else if(layer.getTooltip()){
      layer.unbindTooltip();
    }

    if(popup){
      layer.bindPopup(popup);
    } else if(layer.getPopup()){
      layer.unbindPopup();
    }
  }

  document.getElementById('applyText').addEventListener('click', ()=>{
    if(!selected) return alert('Select a feature first.');
    if(selected instanceof L.Polyline) applyStyle(selected);
    if(selected instanceof L.Marker) setMarkerIcon(selected, document.getElementById('markerIcon').value);
    applyText(selected);
  });

  // Update style live when UI changes if a layer is selected
  ['strokeColor','fillColor','opacity','lineType','markerIcon'].forEach(id=>{
    document.getElementById(id).addEventListener('input', ()=>{
      if(!selected) return;
      if(selected instanceof L.Polyline) applyStyle(selected);
      if(selected instanceof L.Marker && id==='markerIcon') setMarkerIcon(selected, document.getElementById('markerIcon').value);
    })
  });

  // Freehand (stylus-friendly) polyline drawing
  let fhEnabled = false;
  let fhDrawing = false;
  let fhPointerId = null;
  let fhPts = [];
  let fhTemp = null;

  function setFreehandEnabled(on){
    fhEnabled = !!on;
    const btn = document.getElementById('fhEnableBtn');
    if(btn){ btn.textContent = fhEnabled ? 'Freehand Enabled' : 'Enable Freehand'; }
    if(!on){
      if(fhDrawing){ endFreehand(true); }
    }
  }

  function startFreehand(e){
    if(!fhEnabled) return;
    const penOnly = document.getElementById('fhPenOnly').value === 'yes';
    if(penOnly && e.pointerType && e.pointerType !== 'pen') return;

    fhDrawing = true;
    fhPointerId = e.pointerId;
    fhPts = [];

    if(map.dragging && map.dragging.disable) map.dragging.disable();

    const ll = map.mouseEventToLatLng(e);
    fhPts.push(ll);
    fhTemp = L.polyline(fhPts, { color: document.getElementById('strokeColor').value, opacity: parseFloat(document.getElementById('opacity').value) || 0.7, weight: 3 });
    fhTemp.addTo(map);
  }

  function moveFreehand(e){
    if(!fhDrawing || e.pointerId !== fhPointerId) return;
    const minDist = Math.max(0, parseFloat(document.getElementById('fhMinDist').value) || 0);
    const ll = map.mouseEventToLatLng(e);
    const last = fhPts[fhPts.length - 1];
    if(!last || map.distance(last, ll) >= minDist){
      fhPts.push(ll);
      if(fhTemp) fhTemp.setLatLngs(fhPts);
    }
  }

  function endFreehand(cancel){
    if(!fhDrawing) return;
    fhDrawing = false;

    if(map.dragging && map.dragging.enable) map.dragging.enable();

    if(fhTemp){ fhTemp.remove(); fhTemp = null; }

    if(!cancel && fhPts.length > 1){
      const line = L.polyline(fhPts);
      attachCommon(line);
      applyStyle(line);
      applyText(line);
      selectLayer(line);
      if (typeof snapshot === 'function') snapshot();
    }
    fhPts = [];
    fhPointerId = null;
  }

  const container = map.getContainer();
  container.addEventListener('pointerdown', startFreehand);
  container.addEventListener('pointermove', moveFreehand);
  container.addEventListener('pointerup', function(e){ if(e.pointerId===fhPointerId) endFreehand(false); });
  container.addEventListener('pointercancel', function(e){ if(e.pointerId===fhPointerId) endFreehand(true); });

  document.getElementById('fhEnableBtn').onclick = function(){ setFreehandEnabled(true); };
  document.getElementById('fhDisableBtn').onclick = function(){ setFreehandEnabled(false); };

  // Undo/Redo History
  let undoStack = [];
  let redoStack = [];
  let isRestoring = false;
  const HISTORY_LIMIT = 100;

  function snapshot(){
    if(isRestoring) return;
    try{
      const fc = collectGeoJSON();
      const state = JSON.stringify(fc);
      undoStack.push(state);
      if(undoStack.length > HISTORY_LIMIT) undoStack.shift();
      redoStack.length = 0;
      updateUndoRedoUI();
    }catch(e){}
  }
  function loadState(geojson){
    isRestoring = true;
    try{
      drawn.clearLayers();
      map.eachLayer(l=>{ if(l instanceof L.GeoJSON) map.removeLayer(l); });
      restoreFromGeoJSON(geojson);
    } finally {
      isRestoring = false;
      updateUndoRedoUI();
    }
  }
  function canUndo(){ return undoStack.length > 1; }
  function canRedo(){ return redoStack.length > 0; }
  function undo(){ if(!canUndo()) return; const curr = undoStack.pop(); redoStack.push(curr); const prev = JSON.parse(undoStack[undoStack.length-1]); loadState(prev); }
  function redo(){ if(!canRedo()) return; const state = redoStack.pop(); undoStack.push(state); loadState(JSON.parse(state)); }
  function updateUndoRedoUI(){
    const u = document.getElementById('undoBtn');
    const r = document.getElementById('redoBtn');
    if(u){ u.disabled = !canUndo(); u.classList.toggle('disabled', u.disabled); }
    if(r){ r.disabled = !canRedo(); r.classList.toggle('disabled', r.disabled); }
  }
  function initHistory(){
    map.on('pm:create', ()=> snapshot());
    map.on('pm:remove', ()=> snapshot());
    map.on('pm:edit', ()=> snapshot());
    map.on('pm:dragend', ()=> snapshot());
    const importEl = document.getElementById('importFile');
    if(importEl){ importEl.addEventListener('change', ()=> setTimeout(()=> snapshot(), 50)); }
    // Also snapshot after adding pin by lat/lon
    const addLL = document.getElementById('addLatLonBtn');
    if(addLL){ addLL.addEventListener('click', ()=> setTimeout(()=> snapshot(), 0)); }
    snapshot(); // initial
  }
  document.getElementById('undoBtn').onclick = undo;
  document.getElementById('redoBtn').onclick = redo;
  document.addEventListener('keydown', (e)=>{
    const z = e.key==='z' || e.key==='Z';
    const y = e.key==='y' || e.key==='Y';
    if((e.ctrlKey||e.metaKey) && z && !e.shiftKey){ e.preventDefault(); undo(); }
    else if((e.ctrlKey||e.metaKey) && (y || (z && e.shiftKey))){ e.preventDefault(); redo(); }
  });
  let snapshotTimer = null; function scheduleSnapshot(){ clearTimeout(snapshotTimer); snapshotTimer = setTimeout(()=> snapshot(), 400); }
  document.getElementById('applyText').addEventListener('click', ()=> snapshot());
  ;['strokeColor','fillColor','opacity','lineType','markerIcon'].forEach(id=>{ const el = document.getElementById(id); if(el) el.addEventListener('change', scheduleSnapshot); });
  setTimeout(initHistory, 0);

  // Collaboration ‚Äî simple WebSocket transport
  let isRemoteApplying = false;
  function uuidv4(){
    if(window.crypto && crypto.getRandomValues){
      const a = crypto.getRandomValues(new Uint8Array(16));
      a[6] = (a[6] & 0x0f) | 0x40; a[8] = (a[8] & 0x3f) | 0x80;
      const b = [...a].map((x,i)=> (i===4||i===6||i===8||i===10?'-'+('0'+x.toString(16)).slice(-2):('0'+x.toString(16)).slice(-2))).join('');
      return b;
    }
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c=>{
      const r = Math.random()*16|0, v = c==='x'?r:(r&0x3|0x8); return v.toString(16);
    });
  }
  function colorFromName(name){ let h=0; for(let i=0;i<name.length;i++) h=(h*31+name.charCodeAt(i))>>>0; h=h%360; return `hsl(${h} 70% 55%)`; }
  function ensureLayerId(layer){ if(!layer.options._id) layer.options._id='f_'+uuidv4(); }
  function setMetaOnCreate(layer){ ensureLayerId(layer); const now = new Date().toISOString(); layer.options._meta = { createdBy: collab.my.name, createdAt: now, updatedBy: collab.my.name, updatedAt: now }; }
  function updateMetaOnEdit(layer){ const now = new Date().toISOString(); layer.options._meta = Object.assign({}, layer.options._meta||{}, { updatedBy: collab.my.name, updatedAt: now }); }
  function toSingleGeoJSON(layer){ const gj = layer.toGeoJSON(); const props = gj.properties || (gj.properties={}); props._id = layer.options._id || ('f_'+uuidv4()); const m = layer.options._meta||{}; props._createdBy = m.createdBy||collab.my.name; props._createdAt = m.createdAt||new Date().toISOString(); props._updatedBy = m.updatedBy||props._createdBy; props._updatedAt = m.updatedAt||props._createdAt; if(layer instanceof L.Polyline){ props.stroke = layer.options.color || '#ff4757'; props.opacity = layer.options.opacity ?? 0.7; props.dashArray = layer.options.dashArray || null; if(layer instanceof L.Polygon){ props.fill = layer.options.fillColor || '#2ed573'; } } const tt = layer.getTooltip && layer.getTooltip(); if(tt) props.label = tt.getContent(); const pp = layer.getPopup && layer.getPopup(); if(pp) props.popup = pp.getContent(); if(layer instanceof L.Marker && layer.options._am){ props._am = layer.options._am; }
      // metadata
      props._id = layer.options._id || ('f_'+uuidv4());
      const mm = layer.options._meta || {};
      if(mm.createdBy) props._createdBy = mm.createdBy;
      if(mm.createdAt) props._createdAt = mm.createdAt;
      if(mm.updatedBy) props._updatedBy = mm.updatedBy;
      if(mm.updatedAt) props._updatedAt = mm.updatedAt; return gj; }

  function createCursorIcon(name, color){ 
	return L.divIcon({ 
		className: '', 
/*		html: `<div class=\"remote-cursor\" style=\"border-color:${'`'}+color+{'`'}\"><div class=\"dot\" style=\"background:${'`'}+color+{'`'}\"></div><span>${'`'}+name+{'`'}</span></div>`, 	iconSize:[10,10], iconAnchor:[0,0] }); } */
		html: `<div class=\"remote-cursor\" style=\"border-color:${color}\"><div class=\"dot\" style=\"background:${color}\"></div><span>${name}</span></div>`,
 		iconSize:[10,10], 
		iconAnchor:[0,0] 
		}); 
  }


  function createCollab(map, drawn){
    const presenceEl = document.getElementById('presence');
    const nameInput = document.getElementById('collabName');
    const roomInput = document.getElementById('collabRoom');
    const serverInput = document.getElementById('collabServer');
    const followSelect = document.getElementById('followUser');
    const broadcastView = document.getElementById('broadcastView');

    const my = { id: uuidv4(), name: localStorage.getItem('qm_name')||'Guest-'+String(Math.random()).slice(2,6), color: '#7cf' };
    my.color = colorFromName(my.name); nameInput.value = my.name;

    const participants = new Map();
    function renderPresence(){ presenceEl.innerHTML=''; participants.set(my.id,{name:my.name,color:my.color,self:true}); const frag=document.createDocumentFragment(); followSelect.innerHTML='<option value="">(none)</option>'; for(const [id,p] of participants){ const d=document.createElement('div'); d.className='avatar'; d.title=p.name; d.style.color='#fff'; d.style.outline=`2px solid ${p.color}`; d.textContent=p.name.slice(0,2).toUpperCase(); frag.appendChild(d); if(id!==my.id){ const o=document.createElement('option'); o.value=id; o.textContent=p.name; followSelect.appendChild(o);} } presenceEl.appendChild(frag); }

    let ws=null, connected=false, room='';
    function connect(){ 
	const url = serverInput.value.trim(); 
	room = roomInput.value.trim()||'default'; 
	my.name = nameInput.value.trim()||my.name; 
	my.color = colorFromName(my.name); 
	localStorage.setItem('qm_name', my.name); 
	try{ if(ws) ws.close(); }catch(_){ } 
	ws = new WebSocket(url); 
	ws.onopen=()=>{ 
		connected=true; 
		send('hello',{}); 
		send('presence',{}); 
		renderPresence(); 
	}; 
	ws.onmessage=evt=>{ 
		let msg; 
		try{ msg=JSON.parse(evt.data);}catch(_){return;} 
		if(msg.room && msg.room!==room) return; 
		if(msg.user && msg.user.id===my.id) return; 
		handle(msg); 
	}; 
	ws.onclose=()=>{ connected=false; for(const [id,p] of [...participants]){ if(!p.self){ if(p.cursor) map.removeLayer(p.cursor); participants.delete(id);} } renderPresence(); };
 	ws.onerror=()=>{}; 
    }



    function disconnect(){ if(ws){ try{ ws.close(); }catch(_){ } ws=null; connected=false; } }
    function isConnected(){ return connected; }

    function send(type,payload){
	console.log("attempting to send message: type=" +type + " payload="+payload);
	if(!connected) return; 
	const msg=Object.assign({type,room,user:{id:my.id,name:my.name,color:my.color}},payload||{}); 
	try{ ws.send(JSON.stringify(msg)); }catch(_){ } 
    }

    function handle(msg){ const {type,user}=msg; if(!user||!user.id) return; let p = participants.get(user.id)||{name:user.name,color:user.color}; p.name=user.name; p.color=user.color; participants.set(user.id,p); if(type==='presence'||type==='hello'){ renderPresence(); return; } if(type==='cursor'&&msg.latlng){ if(!p.cursor){ p.cursor=L.marker(msg.latlng,{zIndexOffset:10000,icon:createCursorIcon(p.name,p.color)}).addTo(map); } else { p.cursor.setLatLng(msg.latlng);} return; } if(type==='view'&&msg.center&&typeof msg.zoom==='number'){ p.lastView={center:msg.center,zoom:msg.zoom}; return; } if(type==='feature:add'&&msg.feature){ isRemoteApplying=true; try{ addFeatureFromRemote(msg.feature); } finally { isRemoteApplying=false; } return; } if(type==='feature:edit'&&msg.feature){ isRemoteApplying=true; try{ editFeatureFromRemote(msg.feature); } finally { isRemoteApplying=false; } return; } if(type==='feature:remove'&&msg.id){ isRemoteApplying=true; try{ removeFeatureById(msg.id); } finally { isRemoteApplying=false; } return; } }

    function findLayerById(id){ let found=null; drawn.eachLayer(l=>{ if(l.options && l.options._id===id) found=l; }); return found; }
    function addFeatureFromRemote(feat){ L.geoJSON(feat,{ pointToLayer:(feature,latlng)=>{ const m=L.marker(latlng); if(feature.properties&&feature.properties._am){ const v=`${feature.properties._am.iconName},${feature.properties._am.color||'#d33'}`; setMarkerIcon(m,v);} return m; }, onEachFeature:(feature,layer)=>{ attachCommon(layer);
    ensureLayerId(layer); ensureLayerId(layer); const p=feature.properties||{}; layer.options._id=p._id||layer.options._id; layer.options._meta={createdBy:p._createdBy,createdAt:p._createdAt,updatedBy:p._updatedBy,updatedAt:p._updatedAt}; if(layer instanceof L.Polyline){ const opts={color:p.stroke||'#ff4757',opacity:p.opacity ?? 0.7,weight:3,dashArray:p.dashArray||null}; if(layer instanceof L.Polygon){ opts.fillColor=p.fill||'#2ed573'; opts.fillOpacity=p.opacity ?? 0.7; opts.fill=true;} layer.setStyle(opts);} if(p.label){ layer.bindTooltip(p.label,{permanent:true,direction:'center',className:'feature-label'}).openTooltip(); } if(p.popup){ layer.bindPopup(p.popup);} } }).addTo(map); }
    function editFeatureFromRemote(feat){ const id=feat.properties&&feat.properties._id; if(!id) return addFeatureFromRemote(feat); const layer=findLayerById(id); if(!layer){ addFeatureFromRemote(feat); return;} const g=feat.geometry; if(layer.setLatLngs && g){ if(g.type==='LineString'){ layer.setLatLngs(L.GeoJSON.coordsToLatLngs(g.coordinates,0)); } else if(g.type==='Polygon'){ layer.setLatLngs(L.GeoJSON.coordsToLatLngs(g.coordinates,1)); } } const p=feat.properties||{}; if(layer instanceof L.Polyline){ const opts={color:p.stroke||'#ff4757',opacity:p.opacity ?? 0.7,weight:3,dashArray:p.dashArray||null}; if(layer instanceof L.Polygon){ opts.fillColor=p.fill||'#2ed573'; opts.fillOpacity=p.opacity ?? 0.7; opts.fill=true;} layer.setStyle(opts);} if(p.label){ layer.bindTooltip(p.label,{permanent:true,direction:'center',className:'feature-label'}).openTooltip(); } else if(layer.getTooltip()) layer.unbindTooltip(); if(p.popup){ layer.bindPopup(p.popup);} else if(layer.getPopup()) layer.unbindPopup(); layer.options._meta={createdBy:p._createdBy,createdAt:p._createdAt,updatedBy:p._updatedBy,updatedAt:p._updatedAt}; }
    function removeFeatureById(id){ const l=findLayerById(id); if(l) drawn.removeLayer(l); }

    function sendCursor(latlng){ send('cursor',{latlng}); }
    function sendView(){ const c=map.getCenter(); send('view',{center:[c.lat,c.lng],zoom:map.getZoom()}); }
    function sendAdd(layer){ if(isRemoteApplying) return; ensureLayerId(layer); setMetaOnCreate(layer); send('feature:add',{feature:toSingleGeoJSON(layer)}); }
    function sendEdit(layer){ if(isRemoteApplying) return; if(!layer) return; updateMetaOnEdit(layer); send('feature:edit',{feature:toSingleGeoJSON(layer)}); }
    function sendRemove(layer){ if(isRemoteApplying) return; if(!layer) return; const id=layer.options&&layer.options._id; if(id) send('feature:remove',{id}); }

    document.getElementById('collabConnect').onclick=connect;
    document.getElementById('collabDisconnect').onclick=disconnect;
    document.getElementById('jumpToUser').onclick=()=>{ const id=followSelect.value; if(!id) return; const p=participants.get(id); if(p&&p.lastView){ map.setView(p.lastView.center,p.lastView.zoom);} };

    let lastCursorSent=0; map.getContainer().addEventListener('pointermove',(e)=>{ if(!connected) return; const now=performance.now(); if(now-lastCursorSent<50) return; lastCursorSent=now; const ll=map.mouseEventToLatLng(e); sendCursor([ll.lat,ll.lng]); });
    map.on('moveend',()=>{ if(connected && broadcastView.value==='yes') sendView(); });

    map.on('pm:create',e=>{ if(connected) sendAdd(e.layer); });
    map.on('pm:edit',e=>{ if(connected) sendEdit(e.layer); });
    map.on('pm:dragend',e=>{ if(connected) sendEdit(e.layer); });
    map.on('pm:remove',e=>{ if(connected) sendRemove(e.layer); });

    return { connect, disconnect, isConnected, sendAdd, sendEdit, sendRemove, my, participants };
  }

  const collab = createCollab(map, drawn);

  // Basemap switching buttons
  document.getElementById('osmBtn').onclick = ()=>{ if(!map.hasLayer(osm)) { esri.remove(); osm.addTo(map);} };
  document.getElementById('esriBtn').onclick = ()=>{ if(!map.hasLayer(esri)) { osm.remove(); esri.addTo(map);} };

  // Custom tile layer
  document.getElementById('addTileBtn').onclick = ()=>{
    const url = document.getElementById('customTileUrl').value.trim();
    if(!url) return;
    const custom = L.tileLayer(url, { maxZoom: 22, crossOrigin: true, attribution: 'Custom' }).addTo(map);
    overlays[`Custom ${Object.keys(overlays).length+1}`] = custom;
  };

  // GeoTIFF from URL
  document.getElementById('addTiffUrl').onclick = async ()=>{
    const url = document.getElementById('tiffUrl').value.trim();
    if(!url) return;
    await addGeoTiff(url);
  };

  // GeoTIFF from file
  document.getElementById('tiffFile').addEventListener('change', async (e)=>{
    const file = e.target.files[0];
    if(!file) return;
    const arrayBuffer = await file.arrayBuffer();
    const georaster = await parseGeoraster(arrayBuffer);
    const layer = new GeoRasterLayer({ georaster, opacity:0.7, resolution: 256 });
    layer.addTo(map);
    try { map.fitBounds(layer.getBounds()); } catch(_){}
  });

  async function addGeoTiff(url){
    try{
      const response = await fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      const georaster = await parseGeoraster(arrayBuffer);
      const layer = new GeoRasterLayer({ georaster, opacity:0.7, resolution: 256 });
      layer.addTo(map);
      try { map.fitBounds(layer.getBounds()); } catch(_){}
    }catch(err){
      alert('Failed to load GeoTIFF: '+err);
    }
  }

  // Import (GeoJSON or KML)
  document.getElementById('importFile').addEventListener('change', async (e)=>{
    const file = e.target.files[0];
    if(!file) return;
    const text = await file.text();
    let geojson;
    if(file.name.toLowerCase().endsWith('.kml')){
      const dom = new DOMParser().parseFromString(text, 'text/xml');
      geojson = toGeoJSON.kml(dom);
    } else {
      geojson = JSON.parse(text);
    }
    restoreFromGeoJSON(geojson);
  });

  function restoreFromGeoJSON(geojson){
    L.geoJSON(geojson, {
      pointToLayer: (feature, latlng)=>{
        const m = L.marker(latlng);
        if(feature.properties && feature.properties._am){
          const v = `${feature.properties._am.iconName},${feature.properties._am.color||'#d33'}`;
          setMarkerIcon(m, v);
        }
        return m;
      },
      onEachFeature: (feature, layer)=>{
        attachCommon(layer);
    ensureLayerId(layer);
        const p = feature.properties || {};
        // IDs & metadata
        ensureLayerId(layer);
        layer.options._id = p._id || layer.options._id;
        layer.options._meta = { createdBy:p._createdBy, createdAt:p._createdAt, updatedBy:p._updatedBy, updatedAt:p._updatedAt };
        // Style
        if(layer instanceof L.Polyline){
          const opts = { color: p.stroke||'#ff4757', opacity: p.opacity ?? 0.7, weight: 3, dashArray: p.dashArray||null };
          if(layer instanceof L.Polygon){
            opts.fillColor = p.fill||'#2ed573'; opts.fillOpacity = p.opacity ?? 0.7; opts.fill = true;
          }
          layer.setStyle(opts);
        }
        // Text
        if(p.label){ layer.bindTooltip(p.label, { permanent:true, direction:'center', className:'feature-label' }).openTooltip(); }
        if(p.popup){ layer.bindPopup(p.popup); }
      }
    }).addTo(map);
  }

  // Export GeoJSON
  document.getElementById('exportGeoJSON').onclick = ()=>{
    const fc = collectGeoJSON();
    downloadJSON(fc, 'quickmap.geojson');
  };

  // Export KML
  document.getElementById('exportKML').onclick = ()=>{
    const fc = collectGeoJSON();
    const kml = tokml(fc, { documentName: 'QuickMap Export', name: 'name' });
    downloadText(kml, 'quickmap.kml', 'application/vnd.google-earth.kml+xml');
  };

  // Export PNG (via screenshoter)
  document.getElementById('exportPNG').onclick = async ()=>{
    try{
      const blob = await screenshoter.takeScreen('blob');
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'quickmap.png';
      a.click();
    }catch(err){
      alert('PNG export failed (likely CORS on tiles/rasters). Try switching basemap or use your own CORS‚Äëenabled tiles.\n'+err);
    }
  };

  function collectGeoJSON(){
    const features = [];
    drawn.eachLayer(layer=>{
      const gj = layer.toGeoJSON();
      const props = gj.properties || (gj.properties={});
      // Persist styles & texts
      if(layer instanceof L.Polyline){
        props.stroke = layer.options.color || '#ff4757';
        props.opacity = layer.options.opacity ?? 0.7;
        props.dashArray = layer.options.dashArray || null;
        if(layer instanceof L.Polygon){
          props.fill = layer.options.fillColor || '#2ed573';
        }
      }
      const tt = layer.getTooltip && layer.getTooltip();
      if(tt) props.label = tt.getContent();
      const pp = layer.getPopup && layer.getPopup();
      if(pp) props.popup = pp.getContent();
      if(layer instanceof L.Marker && layer.options._am){ props._am = layer.options._am; }
      features.push(gj);
    });
    return { type:'FeatureCollection', features };
  }

  // Download helpers
  function downloadJSON(obj, name){ downloadText(JSON.stringify(obj,null,2), name, 'application/geo+json'); }
  function downloadText(text, name, type){
    const blob = new Blob([text], { type });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = name;
    a.click();
  }

  // Improve labels look
  const css = document.createElement('style');
  css.textContent = `.feature-label{background:rgba(13,19,58,.65);color:#fff;border:1px solid #2f3ea5;border-radius:10px;padding:2px 6px;box-shadow:0 2px 10px rgba(0,0,0,.3);font-weight:600}`;
  document.head.appendChild(css);

})();
</script>
</body>
</html>

